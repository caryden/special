---
name: {{SKILL_NAME}}
description: {{ONE_LINE_DESCRIPTION}}
argument-hint: "<nodes> [--lang <language>] or 'help' — specify nodes to generate, target language, or get guidance"
allowed-tools: ["Bash", "Read", "Write", "Edit", "Glob", "Grep"]
---

# {{SKILL_TITLE}}

{{2-3 sentence description of what this skill generates.}}

## Input

`$ARGUMENTS` accepts:
- **`help`**: Interactive guide to choosing the right nodes and language for your use case
- **Nodes**: space-separated node names to generate (or `all` for the full library)
- **--lang \<language\>**: target language (default: `typescript`). Supported: `python`, `rust`, `go`, `typescript`

Examples:
- `help` — walk through choosing which nodes you need
- `{{EXAMPLE_NODE}}` — generate one node in TypeScript
- `{{EXAMPLE_NODE}} --lang python` — generate one node in Python
- `all --lang rust` — generate the full library in Rust

## Handling `help`

When `$ARGUMENTS` is `help`, read `HELP.md` and use it to guide the user through
node and language selection. The help guide contains a decision tree and common
use-case recipes. Walk through it interactively, asking the user about their
requirements, then recommend specific nodes and a target language.

## Node Graph

```
{{ASCII_NODE_GRAPH}}
```

### Nodes

| Node | Type | Depends On | Description |
|------|------|-----------|-------------|
| `{{node-a}}` | leaf | — | {{description}} |
| `{{node-b}}` | leaf | — | {{description}} |
| `{{node-c}}` | internal | {{node-a}}, {{node-b}} | {{description}} |
| `{{root-node}}` | root | {{deps}} | {{description}} |

### Subset Extraction

- **{{Subset name}}**: `{{node-a}}` + `{{node-c}}`
- **Full library**: all {{N}} nodes

## Key Design Decisions

{{Document any defaults that differ across established libraries.
Include provenance for each choice.}}

| Parameter | Our Value | Source A | Source B |
|-----------|-----------|---------|---------|
| {{param}} | {{value}} | {{value}} | {{value}} |

## Process

1. If `$ARGUMENTS` is `help`, read `HELP.md` and guide the user interactively
2. Read this file for the node graph and design decisions
3. For each requested node (in dependency order), read `nodes/<name>/spec.md`
4. Read `nodes/<name>/to-<lang>.md` for target-language translation hints
5. Generate implementation + tests
6. If the spec is ambiguous, consult `reference/src/<name>.ts` (track what you consulted and why)
7. Run tests — all must pass before proceeding to the next node

### Generated Code Documentation

Every public function, class, type, and interface in generated code must have
idiomatic doc comments in the target language's standard format:

| Language | Format |
|----------|--------|
| TypeScript | JSDoc (`/** */`) with `@param`, `@returns` |
| Python | Google-style docstrings with Args, Returns, Raises |
| Kotlin/Java | KDoc/JavaDoc (`/** */`) with `@param`, `@return`, `@throws` |
| C# | XML doc comments (`///`) with `<summary>`, `<param>`, `<returns>` |
| Go | GoDoc comments (starting with the function/type name) |
| Rust | `///` doc comments with `# Arguments`, `# Returns`, `# Errors` |
| C++ | Doxygen (`/**` or `///`) with `@brief`, `@param`, `@return` |
| Swift | DocC (`///`) with `- Parameters:`, `- Returns:`, `- Throws:` |

Doc comments should describe **what** the function does, its parameters, return
value, and error conditions. Derive content from the node spec — do not invent
behavior not in the spec.

Each generated file must include a **provenance header** as the first comment,
in the file's idiomatic comment style:

```
Generated by {agent} using {model}
From special:{{SKILL_NAME}} (https://github.com/caryden/special)
Node: {node-name}
```

Replace `{agent}`, `{model}`, and `{node-name}` with actual values. The
provenance trace makes generated code traceable back to the skill and model
that produced it.

## Error Handling

{{Document the error handling strategy for this library.}}

## Reference

The TypeScript reference implementation is in `reference/src/`. It is the
authoritative source — consult it when specs are ambiguous, but prefer the
spec and translation hints as primary sources.

All reference code has 100% line and function coverage via `bun test --coverage`.
